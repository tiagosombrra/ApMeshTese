#ifndef _PERFORMER_FRONT_ADVANCER_H_
#define _PERFORMER_FRONT_ADVANCER_H_

#include "Performer/Definitions.h"
#include "Performer/MeshGenerator.h"

namespace Performer
{
	//kind of workaround to allow the use of std::algoritms for heap
	struct HeapWOP
	{
		HeapWOP() : rank(0.0), p(NULL), v(NULL), fa(NULL) {};

		Real rank;
		Data::Point *p;
		Data::Vertex *v;
		const FrontAdvancer *fa;
	};

	//bool better(const HeapWOP *pog1, const HeapWOP *pog2);
	bool better(const HeapWOP &wop1, const HeapWOP &wop2);

	typedef std::vector<HeapWOP> HeapWOPVector;
	//end kind of workaround to allow the use of std::algorithms for heap

	class FrontAdvancer : public Performer::MeshGenerator
	{
	friend
		//bool better(const HeapWOP *wop1, const HeapWOP *wop2);
		bool better(const HeapWOP &wop1, const HeapWOP &wop2);

	public:

		FrontAdvancer(const Data::Boundary *boundary = NULL);
		virtual ~FrontAdvancer();

		virtual void setBoundary(const Data::Boundary *boundary);

		virtual void execute();

	public:

		enum
		{
			NOT_INIT = 0,
			INIT,
			ENDED,
			REJECTED,
			ERROR = 100
		};

		static const Performer::Status notInit;
		static const Performer::Status init;
		static const Performer::Status ended;
		static const Performer::Status rejected;
		static const Performer::Status error;

	protected:

#if USE_EXPERIMENTAL_MESH
		virtual Data::Mesh *makeMesh() const = 0;
#else
		virtual Data::Mesh *makeMesh() const;
#endif //#if USE_EXPERIMENTAL_MESH
		virtual Data::Front *makeFront() const;
		virtual Data::Vertex *makeVertex(Data::Point *p) const;

		//this method returns true if an error was found in the generation of
		//  a new tetrahedron between the input front element and vertex; and
		//  returns false otherwise
		virtual bool isThereError(const Data::FrontElement *fel, const Data::Vertex *best) const;

		//this method returns true if there is no more elements in the front
		// to advance, false otherwise
		virtual bool isEmpty() const;

		//this method rejects a front element, meaning that the given element
		// cannot advance. since there can be different reasons for a rejection,
		// the given code can be used to distinguish them
		virtual bool reject(Data::FrontElement *e, UInt code = 0) const;

		//this method advances a given front element to a given vertex, returning
		// the newly generated element and the newly generated front elements
#if USE_DELETE_FELS
        virtual bool shouldDelete(const Data::FrontElement *e) const;

		virtual Data::Element *advance(Data::FrontElement *e, Data::Vertex *v,
			Data::FrontElementList &newFrontElements, Data::FrontElementList &oldFrontElements);
#else
		virtual Data::Element *advance(Data::FrontElement *e, Data::Vertex *v,
			Data::FrontElementList &newFrontElements);
#endif //#if USE_DELETE_FELS

		//this method advances a given front element to a given vertex
		virtual void advance(Data::FrontElement *e, Data::Vertex *v);

		//this method returns the next element to be advanced
		virtual Data::FrontElement *next() const;

		//given a front element and a point, this method returns the vertex,
		// the front elements and the element that would be generated if this
		// point were valid for the given element. these entities will be used
		// exclusively for validity checks and will be deleted as soon as
		// possible (thus, the vertex created has to copy the given point)
		virtual Data::ElementTuple makeElement(const Data::FrontElement *e,
			const Data::Point *p) const = 0;

		/*//given a front element, and a point, this method returns the front
		// elements that would be generated if this point were valid, along
		// with the vertex created, containing the point. these front elements
		// will be used for validity checks and will be deleted as soon as
		// possible
		virtual Data::FrontElementList makeFrontElements(
			const Data::FrontElement *element, Data::Point *p,
			Data::Vertex *&v) const = 0;

		//given a front element, a list of front elements and a vertex (both
		// created by the makeFrontElements() method), returns the element
		// that would be generated by them. this element will be used for
		// validity checks and will be deleted as soon as possible
		virtual Data::Element *makeElement(const Data::FrontElement *element,
			const Data::FrontElementList &elements, const Data::Vertex *v) const = 0;*/

		//given a front element and a vertex, returns the rank of the vertex
		// with respect to the given front element. the ideal points are also
		// passed for tests, if needed
		virtual Real rank(const Data::FrontElement *e, const Data::Vertex *v,
			const Data::PointList &ideal) const;
		virtual Real rank(const Data::FrontElement *e, const Data::Point *p,
			const Data::PointList &ideal) const;

		//given two ranks, decides if rank1 is better than rank2
		virtual bool better(Real rank1, Real rank2) const = 0;

		//given two ranks, decides if rank1 and rank2 are equal
		virtual bool equal(Real rank1, Real rank2) const = 0;

		//given two vertices with equal ranks, decides which one is better, for
		// the given front element. if the candidate vertex is better than the
		// old vertex, return true. otherwise, return false.
		virtual bool better(const Data::FrontElement *element,
			Data::Vertex *candidate, Data::Vertex *old) const = 0;

		//builds the ideal points for a given front element. these ideal points
		// are the ones that, ideally, would create a new element with the
		// given front element
		virtual Data::PointList ideal(const Data::FrontElement *element, Real factor = 1.0) const = 0;

		//given a front element, this method returns the radius for the
		// hyperspherical search region. the point that will create the new
		// element must not be outside this search region
		virtual Real radius(const Data::FrontElement *element) const = 0;

		//given some ideal points, remove those ones that are not satisfying
		// some constraint (for example, remove those points that are not
		// inside a predetermined box)
		virtual void restricted(const Data::FrontElement *e, Data::PointList &ideal, Real radius) const;

		//find the front vertices that are candidates for generating a new
		// element, when point insertion is not available
		virtual Data::VertexList candidates(const Data::FrontElement *element) const;

		//given a list if ideal vertices and a radius, find the front vertices
		// that are candidates for generating a new element
		virtual Data::VertexList candidates(const Data::PointList &ideal, Real radius) const;
		virtual Data::VertexList candidates(const Data::PointList &ideal, Real radius, Data::VertexList &vertices) const;

		//given a new front element, decide if it is valid, through validity
		// checks with the front
		virtual bool isValid(const Data::FrontElement *element) const;
		virtual bool isValid(const Data::FrontElement *element, const Data::FrontElementList &list) const;

		//given a new point (a newly inserted point), decide if it is valid or
		// not. that would be, for example, test if this point is not inside
		// any existing element and/or is does not intercept any existing front
		// element. the given front element is the one that would form the new
		// element
		virtual bool isValid(const Data::Point *point, const Data::FrontElement *e) const;
		virtual bool isValid(const Data::Point *point, const Data::FrontElement *e, const Data::FrontElementList &list) const;

		//given a front element and a point candidate for insertion, test if,
		// according to the search radius found, the new element would be valid.
		// if radius is negative, then no insertion is available, meaning that
		// the given point was previously created.
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, Real radius) const = 0;

		//given a front element, test if it can advance to the given point. for
		// exemple, make all the new front elments and test if they are valid
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point) const;
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, const Data::VertexList &vertices) const;
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, const Data::FrontElementList &frontElements) const;
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, const Data::VertexList &vertices, const Data::FrontElementList &frontElements) const;

		//given a front element, test if it can advance to the given point. for
		// exemple, make all the new front elments and test if they are valid
		// (simply call this->isValid(element, point)). the inElement boolean
		// parameter is used to indicate that the point was newly created, and
		// should be tested for validity with the current front and the
		// existing mesh
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, bool inElement, Real radius = -1.0) const;
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, bool inElement, const Data::VertexList &vertices, Real radius = -1.0) const;
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, bool inElement, const Data::FrontElementList &frontElements, Real radius = -1.0) const;
		virtual bool isValid(const Data::FrontElement *element, Data::Point *point, bool inElement, const Data::VertexList &vertices, const Data::FrontElementList &frontElements, Real radius = -1.0) const;

		//given a front element and a list of candidate vertices for advancing,
		// decide which ones are valid. these candidates are existing vertices,
		// already present in the mesh. the search radius is also given, for
		// validity checks (if a candidate is too close to the element, with
		// respect to the search radius). obs.: the list of candidates passed
		// as parameter may be changed by the end of the method
		virtual Data::VertexList valid(const Data::FrontElement *element, Data::VertexList &candidates, Real radius = -1.0) const;

		//given a front element and a list of candidate points, decide which
		// ones are valid for advancing. these points do not exist in the mesh,
		// meaning that (possibly) one of them will be inserted. obs.: the list
		// of candidates passed as parameter may change
		virtual Data::VertexList valid(const Data::FrontElement *element, Data::PointList &candidates) const;

		virtual void sortBest(const Data::FrontElement *element, Data::PointList &candidates) const;
		virtual void sortBest(const Data::FrontElement *element, Data::VertexList &candidates,
			const Data::PointList &ideal, Data::RealVector &ranks) const;

		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::PointList &candidates) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::PointList &candidates, const Data::VertexList &vertices) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::PointList &candidates, const Data::FrontElementList &frontElements) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::PointList &candidates, const Data::VertexList &vertices, const Data::FrontElementList &frontElements) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::VertexList &candidates, const Data::PointList &ideal, Real radius = -1.0) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::VertexList &candidates, const Data::PointList &ideal, const Data::VertexList &vertices, Real radius = -1.0) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::VertexList &candidates, const Data::PointList &ideal, const Data::FrontElementList &frontElements, Real radius = -1.0) const;
		virtual Data::Vertex *bestValid(const Data::FrontElement *element, Data::VertexList &candidates, const Data::PointList &ideal, const Data::VertexList &vertices, const Data::FrontElementList &frontElements, Real radius = -1.0) const;

		//given a list of vertices, decide which is thes best one for a
		// given element. the given list of vertices may be changed by the end
		// of this method. the ideal points found are also passed as argument,
		// for any needed test
		virtual Data::Vertex *best(const Data::FrontElement *element, Data::VertexList &valid,
			const Data::PointList &ideal) const;

		//given an element, return the vertex which forms the best element
		// possible. the boolean insert is used to indicate if this front
		// advancer can insert, or not, new points (Steiner points). if insert
		// is false, then it will search, among all the existing vertices,
		// which one is the best. if insert is true, then it not only searches
		// for the best vertex but can also create a new vertex
		//virtual Data::Vertex *best(const Data::FrontElement *element, bool insert) const;

		//input parameter insert was changed to two methods, one when insert was true
		// and one when insertion is false
		virtual Data::Vertex *bestWithInsertion(const Data::FrontElement *element) const;
		virtual Data::Vertex *bestWithInsertionV(const Data::FrontElement *element) const;
		virtual Data::Vertex *bestWithInsertionFE(const Data::FrontElement *element) const;
		virtual Data::Vertex *bestWithInsertionVFE(const Data::FrontElement *element) const;
		virtual Data::Vertex *bestWithoutInsertion(const Data::FrontElement *element) const;

		//given an element, return the vertex which forms the best element
		// possible
		virtual Data::Vertex *best(const Data::FrontElement *element) const = 0;

	protected:

		Data::Front *front;

		const Data::Boundary *boundary;

		/*//debug
	public:
		static Real timeInit;
		static Real timeInitMakingTrees;
		static Real timeExecute;
		static Real timeEnd;

		static Real timeIdeal;
		static Real timeRadius;
		static Real timeRestricted;
		static Real timeCandidates;
		static Real timeFrontElementsInRange;
		static Real timeCandidatesBestValid;
		static Real timeIdealBestValid;

		static Real timeTopologyCandidates;
		static Real timeTopologyBestValid;

		static Real timeIsEmpty;
		static Real timeNext;
		static Real timeNextGeometry;
		static Real timeNextGeometryOut;
		static Real timeNextGeometryReject;
		static Real timeNextTopology;
		static Real timeNextTopologyReject;
		static Real timeBest;
		static Real timeReject;
		static Real timeStatusCheck;
		static Real timeErrorCheck;
		static Real timeAdvance;

		static UInt numBestWithInsertion;
		static UInt numBestWithoutInsertion;*/
	};
}

#endif //#ifndef _PERFORMER_FRONT_ADVANCER_H_
