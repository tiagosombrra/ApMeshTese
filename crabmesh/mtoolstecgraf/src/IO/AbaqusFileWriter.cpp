#include "IO/AbaqusFileWriter.h"

#include "Data/Boundary.h"

IO::AbaqusFileWriter::AbaqusFileWriter() :
	IO::MeshFileWriter::MeshFileWriter()
{
	this->addFiletype(".inp");
}

IO::AbaqusFileWriter::~AbaqusFileWriter()
{

}

void IO::AbaqusFileWriter::write() const
{
	this->writeAbaqus();
}

void IO::AbaqusFileWriter::writeAbaqus() const
{
	this->file << "*Heading" << std::endl;
	this->file << "    ** Job name: job_name_here Model name: model_name_here" << std::endl;
	this->file << "    ** Generated by: CRAbMesh" << std::endl;
	this->file << "    *Preprint, echo=NO, model=NO, history=NO, contact=NO" << std::endl;
	this->file << "    **" << std::endl;
	this->file << "    ** PARTS" << std::endl;
	this->file << "    **" << std::endl;
	this->file << "    *Part, name=Part-1" << std::endl;

	this->file << "*Node" << std::endl;

#if USE_C__11
	std::unordered_map<ULInt, ULInt> vMap;

	vMap.reserve(static_cast<const Data::Boundary *>(this->mesh)->verticesSize());
#else
	std::map<ULInt, ULInt> vMap;
#endif //#if USE_C__11

	ULInt id = 0;

	for (Data::Boundary::ConstVertexIterator iter = static_cast<const Data::Boundary *>(this->mesh)->vBegin();
		 iter != static_cast<const Data::Boundary *>(this->mesh)->vEnd(); iter++)
	{
		Data::Vertex *v = (*iter);

		vMap[v->getId()] = ++id;

		this->file << id << ", " <<
			v->getPoint()->getCoord(0) << ", " <<
			v->getPoint()->getCoord(1) << ", " <<
			v->getPoint()->getCoord(2) << std::endl;
	}

	id = 0;

#if USE_QUADS
	Data::FrontElementList tris, quads;

	for (Data::Boundary::ConstFrontElementIterator iter = static_cast<const Data::Boundary *>(this->mesh)->eBegin();
		 iter != static_cast<const Data::Boundary *>(this->mesh)->eEnd(); iter++)
	{
		Data::FrontElement *fel = (*iter);

		if (fel->numVertices() == 3)
		{
			tris.push_back(fel);
		}
		else if (fel->numVertices() == 4)
		{
			quads.push_back(fel);
		}
	}

	if (!quads.empty())
	{
		this->file << "*Element, type=S4" << std::endl;

		for (Data::FrontElementList::iterator iter = quads.begin();
			 iter != quads.end(); iter++)
		{
			Data::FrontElement *fel = (*iter);

			this->file << ++id;

			for (UInt i = 0; i < fel->numVertices(); i++)
			{
				this->file << ", " << vMap[fel->getVertex(i)->getId()];
			}

			this->file << std::endl;
		}
	}
#endif //#if USE_QUADS

	this->file << "*Element, type=S3" << std::endl;

#if USE_QUADS
	for (Data::FrontElementList::iterator iter = tris.begin();
		 iter != tris.end(); iter++)
#else
	for (Data::Boundary::ConstFrontElementIterator iter = static_cast<const Data::Boundary *>(this->mesh)->eBegin();
		 iter != static_cast<const Data::Boundary *>(this->mesh)->eEnd(); iter++)
#endif //#if USE_QUADS
	{
		Data::FrontElement *fel = (*iter);

		this->file << ++id;

		for (UInt i = 0; i < fel->numVertices(); i++)
		{
			this->file << ", " << vMap[fel->getVertex(i)->getId()];
		}

		this->file << std::endl;
	}

	this->file << "*End Part" << std::endl;
	this->file << "**" << std::endl;
	this->file << "    **" << std::endl;
	this->file << "    ** ASSEMBLY" << std::endl;
	this->file << "    **" << std::endl;
	this->file << "    *Assembly, name=assembly_name_here" << std::endl;
	this->file << "    **" << std::endl;
	this->file << "    *Instance, name=Part-1-1, part=Part-1" << std::endl;
	this->file << "    *End Instance" << std::endl;
	this->file << "    **" << std::endl;
	this->file << "    *End Assembly" << std::endl;

	return;

	/*file << this->treeFactor << std::endl;
	file << this->tolerance << std::endl;

	file << static_cast<const Data::Boundary *>(this->mesh)->verticesSize() << std::endl;

	if (this->dimension == 2)
    {
    	Data::FrontElementList elements = static_cast<const Data::Boundary *>(this->mesh)->getElements();

		Data::Vertex *first = NULL;

    	bool last = false;

    	Data::VertexSet done;

    	while (!elements.empty())
		{
			Data::FrontElement *e = elements.front();

			elements.pop_front();

			if (!first)
			{
				first = e->getVertex(0);
			}

			file << e->getVertex(0)->getId() << " ";
			file << e->getVertex(0)->getPoint()->getCoord(0) << " ";
			file << e->getVertex(0)->getPoint()->getCoord(1) << std::endl;

			done.insert(e->getVertex(0));

			if (last)
			{
				last = false;

				first = NULL;

				file << "-1" << std::endl;

				continue;
			}

			Data::FrontElementList::iterator iter = elements.end();

			for (iter = elements.begin(); iter != elements.end(); iter++)
			{
				if ((*iter)->getVertex(0) == e->getVertex(1))
				{
					if ((*iter)->getVertex(1) == first)
					{
						last = true;
					}

					break;
				}
			}

			if ((iter != elements.begin()) &&
				(iter != elements.end()))
			{
				e = (*iter);

				elements.erase(iter);

				elements.push_front(e);
			}
		}

		//dangling vertices
		for (Data::Boundary::ConstVertexIterator iter = static_cast<const Data::Boundary *>(this->mesh)->vBegin();
			 iter != static_cast<const Data::Boundary *>(this->mesh)->vEnd(); iter++)
		{
			if (done.find((*iter)) == done.end())
			{
				file << (*iter)->getId() << " ";
				file << (*iter)->getPoint()->getCoord(0) << " ";
				file << (*iter)->getPoint()->getCoord(1) << std::endl;
				file << "-1" << std::endl;
			}
		}
    }
    else if (this->dimension == 3)
    {
		//for (Data::VertexList::iterator iter = vertices.begin();
		for (Data::Boundary::ConstVertexIterator iter = static_cast<const Data::Boundary *>(this->mesh)->vBegin();
			 //iter != vertices.end(); iter++)
			 iter != static_cast<const Data::Boundary *>(this->mesh)->vEnd(); iter++)
    	{
			file << (*iter)->getId() << " ";
			file << (*iter)->getPoint()->getCoord(0) << " ";
    		file << (*iter)->getPoint()->getCoord(1) << " ";
    		file << (*iter)->getPoint()->getCoord(2) << std::endl;
    	}

    	//Data::FrontElementList elements = static_cast<const Data::Boundary *>(this->mesh)->getElements();

    	//file << elements.size() << std::endl;
    	file << static_cast<const Data::Boundary *>(this->mesh)->size() << std::endl;

		//for (Data::FrontElementList::iterator iter = elements.begin();
		for (Data::Boundary::ConstFrontElementIterator iter = static_cast<const Data::Boundary *>(this->mesh)->eBegin();
			 //iter != elements.end(); iter++)
			 iter != static_cast<const Data::Boundary *>(this->mesh)->eEnd(); iter++)
    	{
			file << (*iter)->getId() << " ";
			file << (*iter)->getVertex(0)->getId() << " ";
    		file << (*iter)->getVertex(1)->getId() << " ";
    		file << (*iter)->getVertex(2)->getId() << std::endl;
    	}
    }*/
}
