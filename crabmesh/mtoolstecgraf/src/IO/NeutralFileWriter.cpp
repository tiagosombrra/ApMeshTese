#include "IO/NeutralFileWriter.h"

#include "Data/Boundary.h"
#include "Data/Mesh.h"

IO::NeutralFileWriter::NeutralFileWriter() :
	IO::MeshFileWriter::MeshFileWriter()
{
	this->dimension = 0;
	this->boundary = false;

	this->addFiletype(".dat");
	this->addFiletype(".pos");
}

IO::NeutralFileWriter::~NeutralFileWriter()
{

}

void IO::NeutralFileWriter::setDimension(UInt dimension)
{
	this->dimension = dimension;
}

void IO::NeutralFileWriter::setBoundary(bool boundary)
{
	this->boundary = boundary;
}

void IO::NeutralFileWriter::write() const
{
	if (((this->dimension == 2) && (!this->boundary)) ||
		(this->dimension == 3))
	{
		this->writeDat();
	}
}

void IO::NeutralFileWriter::writeDat() const
{
	file << "%HEADER" << std::endl;
    file << "File generated by CRAbMesh" << std::endl;
    file << std::endl;

	Data::VertexList vertices = this->boundary ?
		//static_cast<const Data::Boundary *>(this->mesh)->getVertices() :
		static_cast<const Data::Boundary *>(this->mesh)->getVertices() :
		//static_cast<const Data::Mesh *>(this->mesh)->getVertices(true);
		//static_cast<const Data::Mesh *>(this->mesh)->getSortedVertices();
		static_cast<const Data::Mesh *>(this->mesh)->getVertices();

	if (!this->boundary)
	{
		vertices.sort(Data::Identifiable::less);
	}

	file << "%NODE" << std::endl;
	file << vertices.size() << std::endl;
	file << std::endl;

	file << "%NODE.COORD" << std::endl;
	file << vertices.size() << std::endl;

#if USE_C__11
	typedef std::unordered_map<ULInt, ULInt> ULIntULIntHashMap;
#else
	typedef std::map<ULInt, ULInt> ULIntULIntMap;
#endif //#if USE_C__11

#if USE_C__11
	ULIntULIntHashMap mapVertices;
#else
	ULIntULIntMap mapVertices;
#endif //#if USE_C__11

	ULInt idVertices = 0, idElements = 0;

	for (Data::VertexList::iterator iter = vertices.begin();
		 iter != vertices.end(); iter++)
	{
		Data::Point *p = (*iter)->getPoint();

		mapVertices[(*iter)->getId()] = ++idVertices;

		file << idVertices << " ";
		file << p->getCoord(0) << " ";
		file << p->getCoord(1) << " ";
		file << p->getCoord(2) << std::endl;
	}

	file << std::endl;

	//unused fields
	file << "%INTEGRATION.ORDER" << std::endl;
	file << "1" << std::endl;
	file << "1\t1\t1\t1\t1\t1\t1" << std::endl;
	file << std::endl;
	//end unused fields

	if (this->boundary)
	{
		Data::FrontElementList elements = static_cast<const Data::Boundary *>(this->mesh)->getElements();

		elements.sort(Data::Identifiable::less);

		file << "%ELEMENT" << std::endl;
		file << elements.size() << std::endl;
		file << std::endl;

		if (elements.front()->numVertices() == 4)
		{
			file << "%ELEMENT.Q4" << std::endl;
		}
		else
		{
			file << "%ELEMENT.T3" << std::endl;
		}

		file << elements.size() << std::endl;

		for (Data::FrontElementList::iterator iter = elements.begin();
			 iter != elements.end(); iter++)
		{
			Data::FrontElement *e = (*iter);

			file << ++idElements;

			file << " 1 1 1";

			for (UInt i = 0; i < e->numVertices(); i++)
			{
				file << " " << mapVertices[e->getVertex(i)->getId()];
			}

			file << std::endl;
		}
	}
	else
	{
		//Data::ElementList elements = static_cast<const Data::Mesh *>(this->mesh)->getElements(true);
		//Data::ElementList elements = static_cast<const Data::Mesh *>(this->mesh)->getSortedElements();
		Data::ElementList elements = static_cast<const Data::Mesh *>(this->mesh)->getElements();

		elements.sort(Data::Identifiable::less);

		file << "%ELEMENT" << std::endl;
		file << elements.size() << std::endl;
		file << std::endl;

		file << "%ELEMENT.";

		if (this->dimension == 2)
		{
			file << "T3";
		}
		else
		{
			if (elements.front()->numVertices() == 8)
			{
				file << "BRICK8";
			}
			else
			{
				file << "TETR4";
			}
		}

		file << std::endl;
		file << elements.size() << std::endl;

		for (Data::ElementList::iterator iter = elements.begin();
			 iter != elements.end(); iter++)
		{
			Data::Element *e = (*iter);

			file << ++idElements;

			file << " 1 1";

			if (this->dimension == 2)
			{
				file << " 1";
			}

			for (UInt i = 0; i < e->numVertices(); i++)
			{
				file << " " << mapVertices[e->getVertex(i)->getId()];
			}

			file << std::endl;
		}
	}

	file << std::endl;
	file << "%END";
}
